#include<iostream>
using namespace std;
int n;
int k;
int a[13];
void dfs(int step, int x){
    if(step > k-1){
        int sum = 0;
        for(int i = 0; i < k; i++){
            sum += a[i];
        }
        if(sum == n){
            for(int i = 0; i < k; i++){
                cout << a[i] << " ";
            }
            cout << endl;
        }
        return ;
    }
    for(int i = x; i < n; i++){
        a[step] = i+1;
        dfs(step+1, i);
    }
}
int main(){
    cin >> n >> k;
    dfs(0,0);
}
//此处的x有妙用：无需从头遍历创建状态节点，从前一节点取值及以后创建节点
//这样可以避免6=1+1+4和6=1+4+1的方案重复问题
//以"1-4-1"为例，设定i=x可以在第二个状态节点后，从x=i=4开始遍历创建状态节点，即从4开始
//初始值step=0、i=x=0，以n=6、k=3为例简要介绍流程
//(1)step=0时
// i从x=0到n-1创建状态节点：a[0]=1 (i=0)、a[0]=2 (i=1)、... 、a[0]=n (i=n-1)
// 每次创建完节点后，紧跟着递归调用dfs(step+1,i)
// dfs(1,0) (i=0)、dfs(1,1) (i=1)、...、dfs(1,n-1) (i=n-1)
//(2)step=1时
// 上面各个节点又从x到n-1创立状态节点(通过dfs(step+1,i))
// 对于a[0]=2节点，其创立下一节点的方式为dfs(step[形参] = step+1[实参] = 1, x[形参] = i[实参] = 1)
// 即i从x=1到n-1创建状态节点：a[1]=2 (i=1)、a[1]=3 (i=2)、... 、a[1]=n (i=n-1)
// 可以发现a[1]并未从i=0开始创建a[1]=1节点，而是接着a[0]=2接着从a[1]=2开始创立节点，保证非递减
// ...以此类推即可
// 本质：
// step → step+1：0→1→2→...
// x → i → x： 0 → i的具体取值(0,1,...,n-1) → 作为新的实参传入下一个状态节点创建过程
// 并通过 int i = x，保证了当前节点状态值至少大于前一节点状态值(i+1，等价于i)