归并排序的本质：利用分治策略处理排序问题
根据"归并排序.cpp"尽可能做详细地解释
1. 传入需要进行排序的数组a[]
2. 定义归并排序函数MergeSort()
3. MergeSort函数：
   (1)形参：l和r，分别指代需要排序的数组的首尾两个索引
   (2)关键的3个参数：l、r和mid
      (i)将[l,r]划分为[l,mid]和[mid+1,r]两个子数组
      (ii)mid+1可以等于r，此时子数组只剩1个元素，这也是边界条件
      (iii)边界条件:l≥r。输入参数为l<r时，边界条件为l=r；输出参数为l>r时，从根源上错误，需要排除
   (3)递归调用MergeSort(l,mid)和MergeSort(mid+1,r)：
      在当前节点[l,mid]和[mid+1,r]下，继续创建各自的mid值，并划分出新的两区间(新的两分支)
      *递归的本质就是树结构，这里是二叉树，每次都二分区间
4. MergeSort函数流程实例化
   以l=1、r=4为例
   (1,4) → mid = int(2.5) = 2
   调用MergeSort(1,2)、MergeSort(3,4)
   (1)对于MergeSort(1,2)：
      (1,2) → mid = int(1.5) = 1
      调用MergeSort(1,1)、MergeSort(2,2)
      由于这两个实参取值达到边界条件l≥r，因此返回空值(return ;)
      处理完(1,1)和(2,2)分支，回溯至(1,2)节点，继续执行剩下的"治"的语句
      (1,1)和(2,2)各只有1个元素，执行比较
      将2个元素排序好的结果放在临时数组tmp中索引为l=1至r=2的位置上(其实放在tmp的任意位置都行)
      将tmp中排好的部分赋值给原数组a中索引为l=1至r=2，我们由此解决了子问题(1,2)排序
   (2)对于MergeSort(3,4)
      完全同理，可以获得排序好的子数组(3,4)
   处理完(1,2)和(3,4)的分支，回溯至(1,4)节点，对已经各自排好序的(1,2)和(3,4)子数组执行"治"的语句
   "治"完后，我们解决了原问题(1,4)的排序
   *这里由于1~4为偶数个元素，因此2个子数组长度相等，实际上可能出现左侧数组长度>右侧数组长度的情况
    在"治"的部分要考虑到这个问题
5. "治"：对于治，主要使用的是"双指针遍历&比较 + 单指针赋值"的思路