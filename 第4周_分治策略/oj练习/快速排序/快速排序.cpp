//同样的排序问题，这次使用快速排序解决
#include<iostream>
using namespace std;
int n;
int a[100010];
void QuickSort(int l, int r){
    //调试语句：
    //cout << "l = " << l << " r = " << r << endl;
    //可以观察出死循环卡在哪个递归区间(无限递归出现在区间不可分的情况，无法触发边界条件l=r)
    if(l >= r){
        return;
    }
    int i = l-1; //定义左指针，初始化为l-1(配合do-while的指针先移)
    int j = r+1; //定义右指针，初始化为r+1(配合do-while的指针先移)
    int pivot = a[l]; //定义待排数组第一个元素的值为基准
    while(i < j){
        //只要元素值<基准值，左指针自增1。i会停在[左起]首个大于等于基准值的元素
        //必须使用do-while，判断不能带等号
        //倘若使用"while(a[i] < pivot) i++; while(a[j] > pivot) j--;"，有：
        //对于子问题[3,3]，i会一直卡在索引0，j会一直卡在索引1
        //使用do-while可以保证不会卡死在这里，i、j指针能动起来，这样才能跳出外循环
        //倘若使用"do i++; while(a[i] ≤ pivot)"，同样会产生大问题
        //对于降序排列好的子问题，例如[3,2,1]：
        //由于3≤3，左指针i会自增到索引2，右指针j自减到索引2，i=j指针相撞跳出循环，无法划分数组[3,2,1]
        //若原数组是[3,2,1,4,5]，由于1<4，故i不会继续往后自增(a[3] = 4 > pivot = 3)，
        //这样指针j才有动的机会，但指针j初始值为2+1=3，即便j--先行(j=r)，[l,j]=[l,r]相当于没划分区间
        //如果我们的原数组就是[3,2,1]，由于数组a其余默认元素为0，i指针会越界，直至a[100009]
        //即便是[3,2,1,3,5]，也会越界，尽管我们处理的是[3,2,1]，但此时i在索引3 = j的初始值2+1=3
        //无论如何，后续的j--，必定使得i>j，既不会交换，也不会有任何有效的划分
        //综上这些情况决定了必须让指针先行后判断，遇到基准值也要停下来
        do i++; while(a[i] < pivot); 
        //只要元素值>基准值，右指针自减1。j会停在[右起]首个小于等于基准值的元素
        do j--; while(a[j] > pivot); 
        if(i < j){
            swap(a[i], a[j]);
        }
    }
    //原地操作完，接着划分(分的同时就是在治)
    //由于跳出循环前i++和j--，所以j会到左边组的最后一个元素，i会到右边组的第一个元素
    //*除非元素完全相同，例如[3,3,3]，这种情况下i=j
    QuickSort(l,j);
    QuickSort(j+1,r);
}
int main(){
    cin >> n;
    for(int i = 0; i < n; i++){
        cin >> a[i];
    }
    QuickSort(0, n-1);
    for(int i = 0; i < n; i++){
        cout << a[i] << " ";
    }
}